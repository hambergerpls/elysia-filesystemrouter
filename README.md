# elysia-filesystemrouter

An experimental filesystem router plugin for [Elysia](https://github.com/elysiajs/elysia). Major breaking change may be introduced. Not recommended for production use.

## Installation

```bash
bun install elysia-filesystemrouter
```

## Usage

1. Create a router directory.
```
/.gitignore <-- Can add *.g.ts to ignore generated files
/src
  /router
    /index.ts <-- /
    /users 
        /index.ts <-- /users
        /[id] 
            /index.ts <-- /users/:id
            /posts
                /index.ts <-- /users/:id/posts
    /posts
        /[catch-all].ts <-- /posts/*
...

/package.json
/tsconfig.json

```
2. Instantiate an Elysia instance with the plugin.
```ts
// src/main.ts
import { Elysia } from "elysia";
import { fileSystemRouter } from "elysia-filesystemrouter";

// We export app so that we can use it in our handlers for autocompletions and type checking
export const app = new Elysia()
                .decorate('hi', () => 'hi') // Add decorators, top-level hooks, etc.
                .use(await fileSystemRouter({
                    dir: "./src/router"
                }))
                .listen(3000)
```


3. Inside index.ts/[wildcard].ts files, export desired handlers.
```ts
// src/router/index.ts
import { app } from "src/main.ts";
import { Handler } from "./index.g"; // Handler will be generated by the plugin after running bun --watch src/main.ts

// Creates a handler for all methods
export const onRequest = Handler(app, async ({ path, params }) => `Hello from ${path} with method ${request.method}`)

// Creates a handler for GET method with local hooks
export const onRequestGet = Handler(app, async ({ path, request }) => `Hello from ${path} with method ${request.method}`, {
    afterHandle(context) {
        return 'Hi from local afterHandle'
    }
})

// Creates a handler for POST method with validation
export const onRequestPost = Handler(app, async ({ query: { id } }) => id.toString(), {
    body: t.Object({
        username: t.String(),
        password: t.String()
    }),
    query: t.Object({
        id: t.String()
    }),
    response: {
        200: t.String()
    }
})

// Creates a handler for PUT method with access to decorators
export const onRequestPut = Handler(app, async ({ path, request, hi }) => hi())

// Creates a handler for PATCH method
export const onRequestPatch = Handler(app, async ({ path, request }) => `Hello from ${path} with method ${request.method}`)

// Creates a handler for DELETE method
export const onRequestDelete = Handler(app, async ({ path, request }) => `Hello from ${path} with method ${request.method}`)

```
4. Run the server.
```bash
bun --watch src/main.ts
```
5. Send a request to the server.
```bash
GET http://localhost:3000/ # Hello from / with method GET
```
6. ???
7. Profit

## How it works
The plugin generates a handler function for each endpoint to allow autocompletion and type checking in a file that ends with .g.ts in their respective routes. The end goal is to allow developers to create endpoints using file based routing without sacrificing type safety and autocompletion and other features of Elysia.